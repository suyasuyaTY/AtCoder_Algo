# ABC371+G

## 1. 問題の構造
順列$P$によって、 $i \rightarrow P_i$ という有向辺を張るといくつかの独立したサイクルに分解できる。

辞書順最小の列 $A'$ を作るには、前から順にできるだけ小さく確定させる必要がある。

ただ、サイクルの長さが互いに素とは限らないため、サイクルを独立して最小にしていくだけは解くことができない。

## 2. 回転数判定

それまでの貪欲により、 $X \equiv r_1 \pmod {L_1}$ という条件を満たしている必要があるとする。

次のサイクル $(L_2)$ である回転数$r_2$を取ることができるかどうかは、$X \equiv r_2 \pmod{L_2}$ を同時に満たす $X$ が存在するかどうかと等しい。

通常は、$gcd(L_1, L_2)$ を使って判定するが、サイクルが増えるとオーバーフローしてしまう。そのため、法を素数のべき乗に分解して管理する。

### 2.1. オーバーフローする方法
1. 判定条件： $r_1 \equiv r_2 \pmod {gcd(L_1, L_2)} $
2. 証明
   a. 合同式の定義による書き換え
   $$
   \begin{aligned}
      X &= k_{1} L_{1} + r_{1} \\
      X &= k_{2} L_{2} + r_{2} \\
   \end{aligned}
   $$ 
   b. 等式で整理
   $$
   \begin{aligned}
      k_{2} L_{2} + k_{1} L_{1} = r_{1} + r_{2}\\
   \end{aligned}
   $$ 
   拡張ユークリッドの互除法を思い出すと、整数解が存在する条件は 判定条件と一致する。 $k_{1}$ を適当にとれば $X \ge 0$ になるので、存在する。

### 2.2. 中国剰余定理
$X \equiv r \pmod{L}$ という条件は、 $L = p_1^{c_1} \dots p_m^{c_m}$ とした時、全ての $i$ について、 $X \equiv r \pmod {p_i^{c_i}}$ が成り立つことと同値

各 $p$ に対し、大きい方の法 $p^{c_2}$ の余り $r_2$ を、 小さい方の法 $p^{c_1}$ で割った時、小さい方の余り $r_1$ と一致するか判定するか確認 

## 3. 実装

### 3.1 準備
1. 素因数分解の前計算：エラトステネスの篩などを使い、$N$ 以下の素因数を求めておく。
2. 制約管理：各素数 $p$ について、現在の最大の指数 $e$ とその時のあまり $r$ を記録する配列を用意する。（初期値はすべて制約なし）

### 3.2. アルゴリズムの流れ
1. サイクル分解：未訪問に頂点から順にグラフをたどり、サイクルを検出する
2. サイクル内の最適解探索
   + 現在の見ているサイクルの長さを $L$ とする
   + サイクル内の要点が持つ値を集め、昇順にソートする
   + 小さい候補地から順に、移動回数 $r$ がこれまでの制約と矛盾しないかチェックする
3. 矛盾チェック関数`check(L, r)`
   + $L$ を素因数分解する： $L = p_1^{e_1} p_2^{e_2} \dots$
   + 各素因数$p_k^{e_k}$について
     + `constaraint[p_k]`を見る。
     + 制約${E, R}$がある場合
       + $e_k \le E$：既存の制約 $R$ を $p_k^{e_k}$ で割った余りと、$r$ を $p_k^{e_k}$ で割った余りが一致すればOK
       + $e_k > E$：既存の制約$R$と、$r$を$p_k^{E}$で割った余りが一致すればOK
     + 制約${E, R}$がない場合
       + 確認はいらない
   + すべての素因数で矛盾がなければOK
4. 制約の更新
   + 矛盾しなかった最小の候補値 $r$ を採用する
   + このサイクルの全頂点の値を $A'$ に書き込む
   + この $r$ をもとに`constraint`を更新する
     + 各素因数 $p_k^{e_k}$ について、既存の制約より指数 $e_k$ が大きければ、`constraint[p_k] = {e_k, r % (p_k^{e_k})}`に書き換える