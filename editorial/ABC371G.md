## 1. 問題の構造
順列$P$によって、$i \rightarrow P_i$ という有向辺を張るといくつかの独立したサイクルに分解できる。

辞書順最小の列$A'$を作るには、前から順にできるだけ小さく確定させる必要がある。

ただ、サイクルの長さが互いに素とは限らないため、サイクルを独立して最小にしていくだけは解くことができない。

## 2. 回転数判定

それまでの貪欲により、 $X \equiv r_1 \pmod {L_1}$ という条件を満たしている必要があるとする。

次のサイクル$(L_2)$である回転数$r_2$を取ることができるかどうかは、$X \equiv r_2 \pmod{L_2}$ を同時に満たす $X$ が存在するかどうかと等しい。

通常は、$gcd(L_1, L_2)$を使って判定するが、サイクルが増えるとオーバーフローしてしまう。そのため、法を素数のべき乗に分解して管理する。

### 中国剰余定理
$X \equiv r \pmod{L}$ という条件は、$L = p_1^{c_1} \dots p_m^{c_m}$とした時、全ての$i$について、$X \equiv p_i^{c_i}$ が成り立つことと同値

各$p$に対し、現在課されている条件 $r_1 \pmod{p^{c_1}}$ と確認している条件 $r_2 \pmod{p_{c_2}}$ が矛盾しないかどうかを確認していく

## 実装

### 準備
1. 素因数分解の前計算：エラトステネスの篩などを使い、各 $v \le N$ の素因数を求めておく。
2. 制約管理：各素数 $p$ について、現在の最大の指数 $e$ とその時のあまり $r$ を記録する配列を用意する。（初期値はすべて制約なし）

### アルゴリズムの流れ
1. サイクル分解：未訪問に頂点から順にグラフをたどり、サイクルを検出する
2. サイクル内の最適解探索
   - 現在のサイクルの長さを$L$とする
   - サイクル内の要点が持つ値を集め、昇順にソートする
   - 小さい候補地から順に、移動回数$r$がこれまでの制約と矛盾しないかチェックする
3. 矛盾チェック関数`check(L, r)`
   - $L$を素因数分解する：$L = p_1^{e_1} p_2^{e_2} \dots$
   - 各素因数$p_k^{e_k}$について
     - `constaraint[p_k]`を見る。既に制約${E, R}$がある場合
     - $e_k \le E$：既存の制約 $R$ を $p_k^{e_k}$ で割った余りと、$r$ を $p_k^{e_k}$ で割った余りが一致すればOK
     - $e_k > E$：既存の制約$R$と、$r$を$p_k^{E}$で割った余り一致すればOK
   - すべての素因数で矛盾がなければOK
4. 制約の更新
   - 矛盾しなかった最小の候補値$r$を採用する
   - このサイクルの全頂点の値を$A'$に書き込む
   - この$r$をもとに`constraint`を更新する
     - 各素因数$p_k^{e_k}$について、既存の制約より指数$e_k$が大きければ、`constraint[p_k] = {e_k, r % (p_k^{e_k})}`に書き換える