---
title: bitset高速化
---

`bitset`を使うことで、64 ビットをまとめて計算できるため`for`文で回すよりも 64 倍高速化することができる。

## 高速化できる理由

CPU が一度に処理できる最大単位（64 ビット）でビット演算を一括処理できるから、64 倍になる

- 普通の`bool`：`for`ループを使って 1 ビットずつ処理を行うため、$n$ビットのデータの処理には$n$回の演算が必要
- `bitset`：64 ビットまとめて演算できるため、$n$ビットのデータの処理を$f\frac{n}{64}$回の演算で処理ができる

## 使う際の注意

`bitset`を配列で管理し繰り返し利用する場合、次のループのための`bitset`を初期化方法に注意する。

:::info

### 非効率な方法

```cpp
vector<bitset<2000>> bs(1000);

for (int i = 0; i < m; ++i) {

    for (int k = 0; k < 1000; ++k) {
        bs[k].reset();
    }
    // ... set() を使って必要なビットを立てる ...
}
```

### 効率的な方法

```cpp
vector<bitset<2000>> bs(1000);

for (int i = 0; i < m; ++i) {

    // --- 1. 必要な場所だけに set() する ---
    for (int j = 0; j < n; ++j) {
        bs[a[j][i]].set(j);
    }

    // ... bitsetを使った計算（XORなど） ...

    // --- 2. 使った場所だけ reset() ---
    for (int j = 0; j < n; ++j) {
        bs[a[j][i]].reset(j);
    }
}
```

:::

## シーケンシャルアクセスを利用した高速化

`bitset`を使わなくても、配列へのアクセス順序や`if`文を回避することで高速に動かすことができる。

[bitsetの使い方](https://atcoder.jp/contests/apg4b/tasks/APG4b_ac?lang=ja)