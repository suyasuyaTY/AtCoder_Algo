# 素数の関するライブラリ

## 線形篩

```cpp
struct LinearSieve {
  int n;
  std::vector<int> primes;  // 素数リスト
  std::vector<int> spf;     // Smallest Prime Factor (最小素因数)

  // コンストラクタで篩を実行 (計算量: O(N))
  LinearSieve(int n) : n(n), spf(n + 1) {
    // 初期化: すべての数のSPFをその数自身にする
    for (int i = 0; i <= n; i++) spf[i] = i;

    for (int i = 2; i <= n; i++) {
      // spf[i] == i ならば、iは素数
      if (spf[i] == i) {
        primes.push_back(i);
      }

      // i に既知の素数を掛けて、合成数の SPF を更新する
      for (int p : primes) {
        // p が i の最小素因数 (spf[i]) を超えたら終了
        // これにより、各合成数は「最小素因数」によって一度だけ篩われる
        if (p > spf[i] || (long long)i * p > n) break;

        spf[i * p] = p;
      }
    }
  }

  // 素数判定 (計算量: O(1))
  bool is_prime(int x) const {
    if (x <= 1) return false;
    if (x > n) return false;  // 範囲外対策 (必要に応じて修正)
    return spf[x] == x;
  }

  // 高速素因数分解 (計算量: O(log x))
  // 戻り値: {素因数, 指数} のマップ (例: 12 -> {{2, 2}, {3, 1}})
  vector<pii> factorize(int x) const {
    vector<pii> res;
    while (x > 1) {
      int p = spf[x], ex = 0;
      while (x % p == 0) {
        ex++;
        x /= p;
      }
      res.emplace_back(p, ex);
    }
    return res;
  }

  // 単純な素因数リストを返す版 (例: 12 -> {2, 2, 3})
  vector<int> factorize_flat(int x) const {
    vector<int> res;
    while (x > 1) {
      res.push_back(spf[x]);
      x /= spf[x];
    }
    return res;
  }
};
```