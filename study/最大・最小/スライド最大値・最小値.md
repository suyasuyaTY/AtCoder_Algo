# スライド最大値・最小値
長さ $N$ の配列が与えられたときに、配列の長さ $K$ の区間すべてに対して、その区間内の最大（最小）値を求めることができる。
（2次元以内ならセグメント木でも行ける）

## 仕組み
1. 挿入（挿入する値：`x`）
  - すでに`deque`に挿入されているものと比較し、`x`以下のものをすべて追い出す
2. 削除
   - 先頭要素が部分列がはみ出たら削除する

## スライド最大値
```cpp
template <typename T>
vector<int> slide_max_index(const vector<T> &A, int K) {
  // max_idx[i] : 区間[i - K + 1, i](両側閉区間) における a の最大値を与えるインデックス
  int N = ssize(A);
  vector<int> max_idx(N, 0);

  deque<int> deq;

  for (int i = 0; i < N; i++) {
    while (!deq.empty() && deq.front() <= i - K) deq.pop_front();
    while (!deq.empty() && A[deq.back()] < A[i]) deq.pop_back();
    deq.push_back(i);
    max_idx[i] = deq.front();
  }

  return max_idx;
}
```

## スライド最小値
```cpp
template <typename T>
vector<int> slide_min_index(const vector<T> &A, int K) {
  // min_idx[i] : 区間[i - K + 1, i](両側閉区間) における a の最小値を与えるインデックス
  int N = ssize(A);
  vector<int> min_idx(N, 0);

  deque<int> deq;

  for (int i = 0; i < N; i++) {
    while (!deq.empty() && deq.front() <= i - K) deq.pop_front();
    while (!deq.empty() && A[deq.back()] > A[i]) deq.pop_back();
    deq.push_back(i);
    min_idx[i] = deq.front();
  }

  return min_idx;
}
```