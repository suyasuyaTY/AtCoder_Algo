# `Manacher`

## できること

各`i`について「文字`i`を中心とする最長の回文の半径」を記録した配列`R`を$O(|S|)$で構築する

`R[i]:S[i→i-k]=S[i→i+k]となる最大のk`

## アルゴリズムの解説

### コード

```cpp
int i = 0, j = 0;
while (i < S.size()) {
  while (i-j >= 0 && i+j < S.size() && S[i-j] == S[i+j]) ++j;
  R[i] = j;
  int k = 1;
  while (i-k >= 0 && k+R[i-k] < j) R[i+k] = R[i-k], ++k;
  i += k; j -= k;
}
```

### 解説

1. 現在の中心`i` から左右に1文字ずつ広げていき、文字が一致する限り半径`j` を増やしていく
2. 1で見つかった半径が大きな回文（中心`i` 、半径`j` ）の中に含まれる点`i+k` について考える
    - `i=3` の時を例に考える
    
    ```cpp
    idx:  0 1 2 3 4 5 6 7 8
    char: a b a a a b a b a
    R:    1 2 1 4 1 2 3 2 1
          |<--------->|     // 文字iを中心とする最長の回文
    ```
    
    - この回文の内部では文字列が対象になっていることに着目すると、（回文の中である限り）`S[i-k→0]=S[i+k→|S|]` かつ`S[i-k→|S|]=S[i+k→0]` が成り立つので`R[i-k]=R[i+k]` となる可能性がある
    - 一致する条件は、回文の内側（境界上はダメ）に納まっていることなので`k+R[i-k]<j` となる。（明らかに`i+k` の左側よりも右側の方が伸ばす余裕がないのでこちら側だけ見ればよい）
3. 次のステップ
    - 2の計算で`k` 個分だけ計算をスキップできたので次の中心`i` は `k` だけ進めることができる。
    - 前のステップが終わる条件が、点`i+k`を中心としたときに回文の候補が回文の候補が境界上まで伸ばせることがわかっているので次の半径は`j-k` から見ていってもいい

## 参考記事
[snukeさん](https://snuke.hatenablog.com/entry/2014/12/02/235837)