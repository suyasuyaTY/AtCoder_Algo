# ダブリング

## できること
体の要素数が $N$ 個あって1回移動した時にどの要素に到達するのか定まっているとき、「 $K$ 個先の要素を求めるのに $O(K)$ かかる」ような状況において、

- 前処理： $O(N \log K)$
- クエリ： $O(\log K)$

で行うことができるアルゴリズム。

## ライブラリ

### 通常
```cpp
class Doubling {
 private:
  int n;
  int log_k;
  vector<vector<int>> dp;

 public:
  Doubling(const vector<int> &next_nodes, long long max_steps) {
    n = ssize(next_nodes);

    log_k = 1;
    while ((1LL << log_k) <= max_steps) log_k++;

    dp.assign(log_k, vector<int>(n, -1));

    for (int i = 0; i < n; i++) {
      dp[0][i] = next_nodes[i];
    }

    for (int k = 0; k < log_k - 1; k++) {
      for (int i = 0; i < n; i++) {
        dp[k + 1][i] = dp[k][dp[k][i]];
      }
    }
  }

  int query(int start, long long steps) {
    int now = start;
    for (int k = 0; steps > 0 && now >= 0; k++) {
      if (steps & 1) {
        now = dp[k][now];
      }
      steps >>= 1;
    }
    return now;
  }
};
```

## Kが固定されている場合
ステップが固定されている場合、メモリ領域を節約できる
```cpp
vector<int> solve(long long K, vector<int> A) {
  int N = ssize(A);

  vector<int> res(N);
  iota(res.begin(), res.end(), 0);

  while (K > 0) {
    if (K & 1) {
      vector<int> next_res(N);
      for (int i = 0; i < N; i++) {
        next_res[i] = A[res[i]];
      }
      res = next_res;
    }

    vector<int> next_A(N);
    for (int i = 0; i < N; i++) {
      next_A[i] = A[A[i]];
    }
    A = next_A;

    K >>= 1;
  }

  return res;
}
```